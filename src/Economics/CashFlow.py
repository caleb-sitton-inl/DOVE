# Copyright 2020, Battelle Energy Alliance, LLC
# ALL RIGHTS RESERVED
"""
CashFlow Module
"""
import numpy as np
from collections import defaultdict

from ravenframework.utils import InputData, InputTypes

class CashFlow:
  """
  Hold the economics for a single cash flow, C = m * a * (D/D')^x
  where:
    C is the cashflow ($)
    m is a scalar multiplier
    a is the value of the widget, based on the D' volume sold
    D is the amount of widgets sold
    D' is the nominal amount of widgets sold
    x is the scaling factor
  """
  def __repr__(self) -> str:
    """
    String representation.
    @ In, None
    @ Out, __repr__, string representation
    """
    return f'<DOVE CashFlow "{self.name}">'

  @classmethod
  def get_input_specs(cls) -> type[InputData.ParameterInput]:
    """
    Collects input specifications for this class.
    @ In, None
    @ Out, input_specs, InputData, specs
    """
    cf = InputData.parameterInputFactory(
      "CashFlow",
      descr=r"""node for defining a CashFlow for a particular Component.
                This HERON CashFlow will be used to generate a TEAL CashFlow from
                RAVEN's TEAL plugin. Note a CashFlow generally takes the form
                $C = \alpha \left(\frac{D}{D'}\right)^x$, aggregated depending on
                the \xmlAttr{type}. For more information, see the TEAL plugin for
                RAVEN."""
    )

    cf.addParam(
      "name",
      param_type=InputTypes.StringType,
      required=True,
      descr=r"""the name by which this CashFlow will be identified as
                part of this component. The general name is prefixed by the component
                name, such as ComponentName$\vert$CashFlowName. """,
    )

    cf.addParam(
      "type",
      param_type=InputTypes.makeEnumType("CFType", "CFType", ["one-time", "repeating"]), #type: ignore
      required=True,
      descr=r"""the type of CashFlow to calculate. \xmlString{one-time}
                is suitable for capital expenditure CashFlows, while \xmlString{repeating}
                is used for repeating costs such as operations and maintenance
                (fixed or variable), market sales, or similar.""",
    )

    cf.addParam(
      "taxable",
      param_type=InputTypes.BoolType, #type: ignore
      required=True,
      descr=r"""determines whether this CashFlow is taxed every cycle.""",
    )

    cf.addParam(
      "inflation",
      param_type=InputTypes.StringType,
      required=True,
      descr=r"""determines how inflation affects this CashFlow every cycle.
                See the CashFlow submodule of RAVEN.""",
    )

    cf.addParam(
      "mult_target",
      param_type=InputTypes.BoolType, #type: ignore
      required=False,
      descr=r"""\WARNING{DEPRECATED} indicates whether this parameter should be
                a target of the multiplication factor for NPV matching analyses.
                This parameter is no longer operational. Specifying it in an input
                file does nothing. To access the equivalent feature users should
                now specify within the desired Cash Flow: under the ``reference price''
                node a ``levelized cost'' subnode.""",
    )

    cf.addParam(
      "npv_exempt",
      param_type=InputTypes.BoolType, #type: ignore
      required=False,
      default=False, #type: ignore
      descr=r"""indicates whether this CashFlow should be exempt from
                Net Present Value (NPV) calculations. Setting this parameter to
                ``True'' will allow the CashFlow to be used within the dispatch
                optimization, but will be left out of the finanical computations.
                Thus, users can leverage this feature to motivate the dispatch
                optimization without affecting the financial results. \WARNING{WARNING}:
                this is an advanced feature that changes the interpretations of
                the results typically generated by HERON. Use with caution!""",
    )

    cf.addParam(
      "period",
      param_type=InputTypes.makeEnumType("period_opts", "period_opts", ["hour", "year"]), #type: ignore
      required=False,
      descr=r"""for a \xmlNode{CashFlow} with \xmlAttr{type} \xmlString{repeating},
                indicates whether the CashFlow repeats every time step (\xmlString{hour})
                or every cycle (\xmlString{year})). Generally, CashFlows such as fixed
                operations and maintenance costs are per-cycle, whereas variable costs
                such as fuel and maintenance as well as sales are repeated every time step.""",
    )

    driver = InputData.parameterInputFactory(
      "driver",
      contentType=InputTypes.FloatOrIntType,
      descr=r"""indicates the main driver for this CashFlow, such as the number of
                units sold or the size of the constructed unit. Corresponds to $D$
                in the CashFlow equation.""",
    )
    cf.addSub(driver)

    reference_price = InputData.parameterInputFactory(
      "reference_price",
      contentType=InputTypes.FloatOrIntType,
      descr=r"""indicates the cash value of the reference number of units sold.
                corresponds to $\alpha$ in the CashFlow equation. If \xmlNode{reference_driver}
                is 1, then this is the price-per-unit for the CashFlow.""",
    )

    levelized_cost = InputData.parameterInputFactory(
      "levelized_cost",
      strictMode=True,
      descr=r"""indicates whether HERON and TEAL are meant to solve for the levelized
                price related to this cashflow.""",
    )

    reference_price.addSub(levelized_cost)
    cf.addSub(reference_price)

    reference_driver = InputData.parameterInputFactory(
      "reference_driver",
      contentType=InputTypes.FloatOrIntType,
      descr=r"""determines the number of units sold to which the \xmlNode{reference_price}
                refers. Corresponds to $\prime D$ in the CashFlow equation.""",
    )
    cf.addSub(reference_driver)

    x = InputData.parameterInputFactory(
      "scaling_factor_x",
      contentType=InputTypes.FloatType,
      descr=r"""determines the scaling factor for this CashFlow. Corresponds to
                $x$ in the CashFlow equation. If $x$ is less than one, the per-unit
                price decreases as the units sold increases above the \xmlNode{reference_driver},
                and vice versa.""",
    )
    cf.addSub(x)

    depreciate = InputData.parameterInputFactory(
      "depreciate",
      contentType=InputTypes.IntegerType,
      descr=r"""indicates the number of cycles over which this CashFlow should be
                depreciated. Depreciation schemes are assumed to be MACRS and available
                cycles are listed in the CashFlow submodule of RAVEN.""",
    )
    cf.addSub(depreciate)

    return cf

  def __init__(self, component) -> None:
    """
    Constructor
    @ In, component, CashFlowUser instance, cash flow user to which this cash flow belongs
    @ Out, None
    """
    self._component = component  # component instance to whom this cashflow belongs, if any
    self._driver = None  # ValuedParam "quantity produced", D
    self._alpha = None  # ValuedParam "price per produced", a
    self._reference_driver = None  # ValuedParam "where price is accurate", D'
    self._scaling_factor_x = None  # ValuedParam "economy of scale", x
    self.name = None  # base name of cash flow
    self._type = None  # needed? one-time, yearly, repeating
    self._taxable = None  # apply tax or not
    self._inflation = None  # apply inflation or not
    self._npv_exempt: bool = False  # inlcude cashflow in NPV calculation
    self._depreciate = None
    self._period: str = "hour"  # period for recurring cash flows
    self._signals = set()  # variable values needed for this cash flow
    self._crossrefs = defaultdict(dict)
    self._price_is_levelized = False

  def _set_value(self, name, spec) -> None:
    """
    """
    setattr(self, name, spec.value)

  def _set_fixed_param(self, name, value) -> None:
    """
    """
    setattr(self, name, value)

  def read_input(self, item) -> None:
    """
    Sets settings from input file
    @ In, item, InputData.ParameterInput, parsed specs from user
    @ Out, None
    """
    self.name = item.parameterValues["name"]
    self._taxable = item.parameterValues["taxable"]
    self._inflation = item.parameterValues["inflation"]
    self._type = item.parameterValues["type"]
    self._period = item.parameterValues.get("period", "hour")
    self._npv_exempt = item.parameterValues.get("npv_exempt", False)
    
    for sub in item.subparts:
      name = sub.getName()
      match (name := sub.getName()):
        case "driver" | "reference_driver" | "scaling_factor_x":
          self._set_value(f"_{name}", sub)
        case "reference_price":
          self.set_reference_price(sub)
        case "depreciate":
          self._depreciate = sub.value
        case _:
          raise IOError(f"Unrecognized 'CashFlow' node: {sub.getName()}")

    if self._driver is None:
      raise IOError(f"No <driver> node provided for CashFlow {self.name}!")
    if self._reference_driver is None:
      self._set_fixed_param("_reference_driver", 1)
    if self._scaling_factor_x is None:
      self._set_fixed_param("_scaling_factor_x", 1)

  def set_reference_price(self, node) -> None:
    """
    Sets the reference_price attribute based on given ValuedParam or if Levelized Cost
    @ In, node, InputParams.ParameterInput, reference_price head node
    @ Out, price_is_levelized, bool, are we computing levelized cost for this cashflow?
    """
    for sub in node.subparts:
      if sub.name == "levelized_cost":
        self._price_is_levelized = True
        __ = node.popSub("levelized_cost")

    try:
      self._set_value("_alpha", node)
    except AttributeError as e:
      if self._price_is_levelized:
        self._set_fixed_param("_alpha", 1)
      else:
        raise IOError(f"No <reference_price> node provided for CashFlow {self.name}!") from e

  # Not none set it to default 1
  def get_period(self) -> str:
    """
    Getter for Recurring cashflow period type.
    @ In, None
    @ Out, period, str, 'hourly' or 'yearly'
    """
    return self._period

  def get_crossrefs(self):
    """
    Accessor for cross-referenced entities needed by this cashflow.
    @ In, None
    @ Out, crossrefs, dict, cross-referenced requirements dictionary
    """
    return self._crossrefs

  def set_crossrefs(self, refs) -> None:
    """
    Setter for cross-referenced entities needed by this cashflow.
    @ In, refs, dict, cross referenced entities
    @ Out, None
    """
    # set up pointers
    for attr, obj in refs.items():
      valued_param = self._crossrefs[attr]
      valued_param.set_object(obj)
    # check on VP setup
    for attr, vp in self._crossrefs.items():
      vp.crosscheck(self._component.get_interaction())

  def evaluate_cost(self, activity, values_dict):
    """
    Evaluates cost of a particular scenario provided by "activity".
    @ In, activity, pandas.Series, multi-indexed array of scenario activities
    @ In, values_dict, dict, additional values that may be needed to evaluate cost
    @ In, t, int, time index at which cost should be evaluated
    @ Out, cost, float, cost of activity
    """
    # note this method gets called a LOT, so speedups here are quite effective
    # add the activity to the dictionary
    values_dict["HERON"]["activity"] = activity
    params = self.calculate_params(values_dict)
    return params["cost"]

  def calculate_params(self, values_dict):
    """
    Calculates the value of the cash flow parameters.
    @ In, values_dict, dict, mapping from simulation variable names to their values (as floats or numpy arrays)
    @ Out, params, dict, dictionary of parameters mapped to values including the cost
    """
    # TODO maybe don't cast these as floats, as they could be symbolic expressions (seems unlikely)
    Dp = float(self._reference_driver.evaluate(values_dict, target_var="reference_driver")[0]["reference_driver"])
    x = float(self._scaling_factor_x.evaluate(values_dict, target_var="scaling_factor_x")[0]["scaling_factor_x"])
    a = self._alpha.evaluate(values_dict, target_var="reference_price")[0]["reference_price"]
    D = self._driver.evaluate(values_dict, target_var="driver")[0]["driver"]
    cost = a * (D / Dp) ** x
    params = {
      "alpha": a,
      "driver": D,
      "ref_driver": Dp,
      "scaling": x,
      "cost": cost,
    }  # TODO float(cost) except in pyomo it's not a float
    return params

  def get_driver(self):
    """
    Getter for Cashflow Driver
    @ In, None
    @ Out, driver, ValuedParam, valued param for the cash flow driver
    """
    return self._driver

  def get_type(self):
    """
    Getter for Cashflow Type
    @ In, None
    @ Out, type, str, one-time, yearly, repeating
    """
    return self._type

  def get_depreciation(self):
    """
    Getter for Cashflow depreciation
    @ In, None
    @ Out, depreciate, int or None
    """
    return self._depreciate

  def is_taxable(self):
    """
    Getter for Cashflow taxable boolean
    @ In, None
    @ Out, taxable, bool, is cashflow taxable?
    """
    return self._taxable

  def is_inflation(self):
    """
    Getter for Cashflow inflation boolean
    @ In, None
    @ Out, inflation, bool, is inflation applied to cashflow?
    """
    return self._inflation

  def is_mult_target(self):
    """
    Getter for Cashflow mult_target boolean
    @ In, None
    @ Out, taxable, bool, is cashflow a multiplier target?
    """
    return self._price_is_levelized

  def is_npv_exempt(self) -> bool:
    """
    Getter for Cashflow npv_exempt boolean
    @ In, None
    @ Out, npv_exempt, bool, is cashflow exempt from NPV calculations?
    """
    return self._npv_exempt
