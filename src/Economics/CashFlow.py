# Copyright 2024, Battelle Energy Alliance, LLC
# ALL RIGHTS RESERVED
"""
CashFlow Module
"""
from typing import Any
from collections import defaultdict

from ravenframework.utils import InputData, InputTypes

class CashFlow:
  """
  Hold the economics for a single cash flow, C = m * a * (D/D')^x
  where:
    C is the cashflow ($)
    m is a scalar multiplier
    a is the value of the widget, based on the D' volume sold
    D is the amount of widgets sold
    D' is the nominal amount of widgets sold
    x is the scaling factor
  """
  def __repr__(self) -> str:
    """
    String representation.
    @ In, None
    @ Out, __repr__, string representation
    """
    return f'<DOVE CashFlow "{self.name}">'

  @classmethod
  def get_input_specs(cls) -> type[InputData.ParameterInput]:
    """
    Collects input specifications for this class.
    @ In, None
    @ Out, input_specs, InputData, specs
    """
    cf = InputData.parameterInputFactory(
      "CashFlow",
      descr=r"""node for defining a CashFlow for a particular Component.
                This HERON CashFlow will be used to generate a TEAL CashFlow from
                RAVEN's TEAL plugin. Note a CashFlow generally takes the form
                $C = \alpha \left(\frac{D}{D'}\right)^x$, aggregated depending on
                the \xmlAttr{type}. For more information, see the TEAL plugin for
                RAVEN."""
    )

    cf.addParam(
      "name",
      param_type=InputTypes.StringType,
      required=True,
      descr=r"""the name by which this CashFlow will be identified as
                part of this component. The general name is prefixed by the component
                name, such as ComponentName$\vert$CashFlowName. """,
    )

    cf.addParam(
      "type",
      param_type=InputTypes.makeEnumType("CFType", "CFType", ["one-time", "repeating"]), #type: ignore
      required=True,
      descr=r"""the type of CashFlow to calculate. \xmlString{one-time}
                is suitable for capital expenditure CashFlows, while \xmlString{repeating}
                is used for repeating costs such as operations and maintenance
                (fixed or variable), market sales, or similar.""",
    )

    cf.addParam(
      "taxable",
      param_type=InputTypes.BoolType, #type: ignore
      required=False,
      default="True",
      descr=r"""determines whether this CashFlow is taxed every cycle.""",
    )

    cf.addParam(
      "inflation",
      param_type=InputTypes.StringType,
      required=False,
      default="none", # type: ignore
      descr=r"""determines how inflation affects this CashFlow every cycle.
                See the CashFlow submodule of RAVEN.""",
    )

    cf.addParam(
      "npv_exempt",
      param_type=InputTypes.BoolType, #type: ignore
      required=False,
      default="False",
      descr=r"""indicates whether this CashFlow should be exempt from
                Net Present Value (NPV) calculations. Setting this parameter to
                ``True'' will allow the CashFlow to be used within the dispatch
                optimization, but will be left out of the finanical computations.
                Thus, users can leverage this feature to motivate the dispatch
                optimization without affecting the financial results. \WARNING{WARNING}:
                this is an advanced feature that changes the interpretations of
                the results typically generated by HERON. Use with caution!""",
    )

    cf.addParam(
      "period",
      param_type=InputTypes.makeEnumType("period_opts", "period_opts", ["hour", "year"]), #type: ignore
      required=False,
      default="hour",
      descr=r"""for a \xmlNode{CashFlow} with \xmlAttr{type} \xmlString{repeating},
                indicates whether the CashFlow repeats every time step (\xmlString{hour})
                or every cycle (\xmlString{year})). Generally, CashFlows such as fixed
                operations and maintenance costs are per-cycle, whereas variable costs
                such as fuel and maintenance as well as sales are repeated every time step.""",
    )

    cf.addParam(
      "depreciate",
      param_type=InputTypes.IntegerType, # type: ignore
      required=False,
      default=None, # type: ignore
      descr=r"""indicates the number of cycles over which this CashFlow should be
                depreciated. Depreciation schemes are assumed to be MACRS and available
                cycles are listed in the CashFlow submodule of RAVEN.""",
    )

    driver = InputData.parameterInputFactory(
      "driver",
      contentType=InputTypes.FloatOrIntType,
      descr=r"""indicates the main driver for this CashFlow, such as the number of
                units sold or the size of the constructed unit. Corresponds to $D$
                in the CashFlow equation.""",
    )
    cf.addSub(driver)

    reference_price = InputData.parameterInputFactory(
      "reference_price",
      contentType=InputTypes.FloatOrIntType,
      descr=r"""indicates the cash value of the reference number of units sold.
                corresponds to $\alpha$ in the CashFlow equation. If \xmlNode{reference_driver}
                is 1, then this is the price-per-unit for the CashFlow.""",
    )

    levelized_cost = InputData.parameterInputFactory(
      "levelized_cost",
      strictMode=True,
      descr=r"""indicates whether HERON and TEAL are meant to solve for the levelized
                price related to this cashflow.""",
    )

    reference_price.addSub(levelized_cost)
    cf.addSub(reference_price)

    reference_driver = InputData.parameterInputFactory(
      "reference_driver",
      contentType=InputTypes.FloatOrIntType,
      descr=r"""determines the number of units sold to which the \xmlNode{reference_price}
                refers. Corresponds to $\prime D$ in the CashFlow equation.""",
    )
    cf.addSub(reference_driver)

    x = InputData.parameterInputFactory(
      "scaling_factor_x",
      contentType=InputTypes.FloatType,
      descr=r"""determines the scaling factor for this CashFlow. Corresponds to
                $x$ in the CashFlow equation. If $x$ is less than one, the per-unit
                price decreases as the units sold increases above the \xmlNode{reference_driver},
                and vice versa.""",
    )
    cf.addSub(x)

    return cf

  def __init__(self, component) -> None:
    """
    Constructor
    @ In, component, CashFlowUser instance, cash flow user to which this cash flow belongs
    @ Out, None
    """

    self._driver = None  # ValuedParam "quantity produced", D
    self._alpha = None  # ValuedParam "price per produced", a
    self._reference_driver = None  # ValuedParam "where price is accurate", D'
    self._scaling_factor_x = None  # ValuedParam "economy of scale", x

    self.component = component  # component instance to whom this cashflow belongs, if any
    self.name: str = "placeholder"  # base name of cash flow
    self.has_inflation: bool = False  # apply inflation or not
    self.is_npv_exempt: bool = False  # exclude cashflow in NPV calculation?
    self.is_price_levelized: bool = False
    self.is_taxable: bool = True
    self.depreciation: None | int = None

    self.type: str = "repeating"  # needed? one-time, yearly, repeating
    self.period: str = "hour"  # period for recurring cash flows
    self._signals = set()  # variable values needed for this cash flow
    self._crossrefs: defaultdict[str, Any] = defaultdict(dict)


  def _set_value(self, name, spec) -> None:
    """
    """
    setattr(self, name, spec.value)

  def _set_fixed_param(self, name, value) -> None:
    """
    """
    setattr(self, name, value)

  def read_input(self, item) -> None:
    """
    Sets settings from input file
    @ In, item, InputData.ParameterInput, parsed specs from user
    @ Out, None
    """
    self.name = item.parameterValues["name"] # required or fails
    self.type = item.parameterValues["type"] # required or fails
    self.period = item.parameterValues.get("period", self.period)
    self.is_taxable = item.parameterValues.get("taxable", self.is_taxable)
    self.is_npv_exempt = item.parameterValues.get("npv_exempt", self.is_npv_exempt)
    self.has_inflation = item.parameterValues.get("inflation", self.has_inflation)
    self.depreciation = item.parameterValues.get("depreciate", self.depreciation)

    for sub in item.subparts:
      match (item_name := sub.getName()):
        case "driver" | "reference_driver" | "scaling_factor_x":
          self._set_value(f"_{item_name}", sub)
        case "reference_price":
          self.set_reference_price(sub)
        case _:
          raise IOError(f"Unrecognized 'CashFlow' node: {item_name}")

    if self._driver is None:
      raise IOError(f"No <driver> node provided for CashFlow {self.name}!")
    if self._reference_driver is None:
      self._set_fixed_param("_reference_driver", 1)
    if self._scaling_factor_x is None:
      self._set_fixed_param("_scaling_factor_x", 1)

  def set_reference_price(self, node) -> None:
    """
    Sets the reference_price attribute based on given ValuedParam or if Levelized Cost
    @ In, node, InputParams.ParameterInput, reference_price head node
    @ Out, price_is_levelized, bool, are we computing levelized cost for this cashflow?
    """
    for sub in node.subparts:
      if sub.name == "levelized_cost":
        self.is_price_levelized = True
        __ = node.popSub("levelized_cost")

    try:
      self._set_value("_alpha", node)
    except AttributeError as e:
      if self.is_price_levelized:
        self._set_fixed_param("_alpha", 1)
      else:
        raise IOError(f"No <reference_price> node provided for CashFlow {self.name}!")

  def evaluate_cost(self, activity, meta):
    pass

  def calculate_params(self, meta):
    pass

  def get_driver(self):
    """
    Getter for Cashflow Driver
    @ In, None
    @ Out, driver, ValuedParam, valued param for the cash flow driver
    """
    return self._driver
